var fs = require('fs');
var util = require('util');
var path = require('path');
var VFSError = require('./error');
var when = require('when');

/**
 * In memory file system
 */
var MemFS = require('./vfs').inherits(function() {
    this.options.cwd = this.options.cwd || '/';
    this.tree = {
    };
});

MemFS.prototype._getByPath = function(tree, p) {
    if (arguments.length === 1) {
        p = tree;
        tree = this.tree;
    }
    if (p === '') {
        return null;
    }

    if (p === '/') {
        return tree;
    }

    if (typeof p === 'string') {
        p = p.split('/');
    } else if (!util.isArray(p)) {
        return null;
    }

    if (p.length === 0) {
        return null;
    }

    var current = p.shift();
    if (current === '') {
        return this._getByPath(tree, p);
    }

    if (!tree.hasOwnProperty(current)) {
        return null;
    }

    // found
    if (p.length === 0) {
        return tree[current];
    } else {
        return this._getByPath(tree[current], p);
    }
};

MemFS.prototype.rename = function(oldPath, newPath, cb) {
    if (!cb) {
        return this.promise(this.rename, oldPath, newPath);
    }

    oldPath = this.resolve(oldPath);
    newPath = this.resolve(newPath);

    this.stat(oldPath)
    .then(function(stats) {
        return this.stat(newPath)
        .then(function(stats) {
            throw new VFSError(newPath, 'EEXIST');
        }, function(err) {
            if (err.code === 'ENOENT') {
                return when();
            }
        });
    })
    .then(function() {
        var parent = path.dirname(newPath);
        var name = path.basename(newPath);

        return this.stat(parent)
        .then(function(stats) {
            if (!stats.isDirectory()) {
                throw new VFSError(parent, 'ENOTDIR');
            }

            var oldParent = path.dirname(oldPath);
            var oldName = path.basename(oldPath);
            var oldParentNode = this._getByPath(oldParent);
            var newParentNode = this._getByPath(parent);
            newParentNode[name] = this._getByPath(oldPath);
            delete oldParentNode[oldName];
        });
    })
    .done(function() {
        cb();
    }, function(err) {
        cb(err);
    });
};

MemFS.prototype.stat = function(p, cb) {
    if (!cb) {
        return this.promise(this.stat, p);
    }

    try {
        cb(null, this.statSync(p));
    } catch (e) {
        cb(e);
    }
};

MemFS.prototype.statSync = function(p) {
    p = this.resolve(p);
    var node = this._getByPath(p);

    if (node === null) {
        throw new VFSError(null, 'ENOENT');
    }

    var stats = new fs.Stats();
    if (Buffer.isBuffer(node)) {
        stats.mode = 0100777;
    } else {
        stats.mode = 040777;
    }

    return stats;
}

MemFS.prototype.mkdir = function(p, mode, cb) {
    if (cb === undefined) {
        cb = mode;
        mode = undefined;
    }

    if (!cb) {
        return this.promise(this.mkdir, p, mode);
    }

    p = this.resolve(p);
    this.promise(this.stat, p)
    .then(function(stats) {
        throw new VFSError(p, 'EEXIST');
    }, function(error) {
        if (error.code !== 'ENOENT') {
            throw error;
        }

        var parent = path.dirname(p);
        var name = path.basename(p);
        // check existence of parent
        return this.promise(this.stat, parent)
            .then(function(stats) {
                if (!stats.isDirectory()) {
                    throw new VFSError(parent, 'ENOTDIR');
                }

                // mkdir
                var node = this._getByPath(parent);
                node[name] = {};
            });
    })
    .then(function() {
        cb();
    }, function(e) {
        cb(e);
    })
    .done();
};


MemFS.prototype.readdir = function(p, cb) {
    if (!cb) {
        return this.promise(this.readdir, path);
    }

    p = this.resolve(p);

    this.stat(p)
    .then(function(stats) {
        if (!stats.isDirectory()) {
            throw new VFSError(p, 'ENOTDIR');
        }
    })
    .done(function() {
        var node = this._getByPath(p);
        cb(null, Object.getOwnPropertyNames(node));
    }, function(err) {
        cb(err);
    })
};

MemFS.prototype.readFile = function(filename, options, cb) {
    if (typeof options === 'function') {
        cb = options;
        options = undefined;
    }

    if (!cb) {
        return this.promise(this.readFile, filename, options);
    }

    options = options || {};

    filename = this.resolve(filename);
    this.promise(this.stat, filename)
    .then(function(stats) {
        if (stats.isDirectory()) {
            throw new VFSError(filename, 'EISDIR');
        }
    })
    .then(function() {
        var node = this._getByPath(filename);
        if (!options.encoding) {
            cb(null, node);
        } else {
            cb(null, node.toString(options.encoding));
        }
    }, function(err) {
        cb(err);
    })
    .done();
};

MemFS.prototype.writeFile = function(filename, data, options, cb) {
    if (typeof options === 'function') {
        cb = options;
        options = undefined;
    }

    if (!cb) {
        return this.promise(this.writeFile, filename, data, options);
    }

    options = options || {};
    var encoding = (encoding in options)?options.encoding:'utf8';

    filename = this.resolve(filename);
    parent = path.dirname(filename);
    name = path.basename(filename);
    this.promise(this.stat, filename)
    .then(function(stats) {
        if (stats.isDirectory()) {
            throw new VFSError(filename, 'EISDIR');
        }
    }, function(err) {
        if (err.code != 'ENOENT') {
            throw err;
        }

        return this.promise(this.stat, parent)
            .then(function(stats) {
                if (!stats.isDirectory()) {
                    throw new VFSError(parent, 'ENOTDIR');
                }
            });
    })
    .then(function() {
        var node = this._getByPath(parent);
        if (Buffer.isBuffer(data)) {
            node[name] = data;
        } else {
            node[name] = new Buffer(data.toString(), encoding);
        }
        cb();
    }, function(err) {
        cb(err);
    })
    .done();
};

MemFS.prototype.unlink = function(p, cb) {
    if (!cb) {
        return this.promise(this.unlink, p);
    }

    this.promise(this.stat, p)
    .then(function(stats) {
        if (stats.isDirectory()) {
            throw new VFSError(p, 'EISDIR');
        }

        var parentNode = this._getByPath(path.dirname(p));
        delete parentNode[path.basename(p)];
    }).done(function() {
        cb();
    }, function(err) {
        cb(err);
    });
};

MemFS.prototype.rmdir = function(p, cb) {
    if (!cb) {
        return this.promise(this.rmdir, p);
    }

    p = this.resolve(p);

    this.promise(this.stat, p)
    .then(function(stats) {
        if (!stats.isDirectory()) {
            throw new VFSError(p, 'ENOTDIR');
        }

        var node = this._getByPath(p);

        if (Object.getOwnPropertyNames(node).length !== 0) {
            throw new VFSError(p, 'ENOTEMPTY');
        }

        var parentNode = this._getByPath(path.dirname(p));
        delete parentNode[path.basename(p)];
    })
    .done(function() {
        cb();
    }, function(err) {
        cb(err);
    });
};

MemFS.prototype.watch = function(filename, listener) {
    throw notImplemented('watch');
};

module.exports = MemFS;