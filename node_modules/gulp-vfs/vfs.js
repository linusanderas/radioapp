'use strict';

var through2 = require('through2');
var path = require('path');
var when = require('when');
require('when/monitor/console');
var VirtualFileSystemError = require('./error');
var inherits = require('util').inherits;
var glob = require('./lib/glob');
var src = require('./lib/vinyl-fs').src;
var dest = require('./lib/vinyl-fs').dest;
var emptyFunction = function() {};

/**
 * VFS Constructor
 * @param {Object} options Global or default options, following options are used by all sub classes:
 *  - cwd
 *  - mode
 */
function VirtualFileSystem(options) {
    this.options = options;
}

function notImplemented(method) {
    return new VirtualFileSystemError('Method not implemented: ' + method);
}

VirtualFileSystem.prototype.resolve = function() {
    var args = Array.prototype.slice.call(arguments);
    args.unshift(this.options.cwd);
    return path.resolve.apply(null, args);
};

VirtualFileSystem.prototype.promise = function() {
    var deferred = when.defer();
    var args = Array.prototype.slice.call(arguments);
    var fn = args.shift();
    args.push(function(err, data) {
        if (err) {
            return deferred.reject(err);
        }

        return deferred.resolve(data);
    });

    fn.apply(this, args);

    return deferred.promise.with(this);
};

VirtualFileSystem.prototype.cwd = function() {
    return this.options.cwd;
};

/**
 * fs APIs
 * Sub class should implement these methods
 */

VirtualFileSystem.prototype.rename = function(oldPath, newPath, cb) {
    oldPath = this.resolve(oldPath);
    newPath = this.resolve(newPath);

    cb(notImplemented('rename'));
};

VirtualFileSystem.prototype.stat = function(p, cb) {
    cb && cb(notImplemented('stat'));
};

VirtualFileSystem.prototype.unlink = function(p, cb) {
    cb && cb(notImplemented('unlink'));
};

VirtualFileSystem.prototype.rmdir = function(p, cb) {
    cb && cb(notImplemented('rmdir'));
};

VirtualFileSystem.prototype.mkdir = function(p, mode, cb) {
    if (typeof mode === 'function') {
        cb = mode;
        mode = undefined;
    }

    cb && cb(notImplemented('mkdir'));
};


VirtualFileSystem.prototype.readdir = function(p, cb) {
    cb && cb(notImplemented('readdir'));
};

VirtualFileSystem.prototype.readFile = function(filename, options, cb) {
    if (typeof options === 'function') {
        cb = options;
        options = undefined;
    }
    
    cb && cb(notImplemented('readFile'));
};

VirtualFileSystem.prototype.writeFile = function(filename, data, options, cb) {
    if (typeof options === 'function') {
        cb = options;
        options = undefined;
    }

    cb && cb(notImplemented('writeFile'));
};

VirtualFileSystem.prototype.watch = function(filename, listener) {
    throw notImplemented('watch');
};

/**
 * Extra APIs
 */

/**
 * mkdirP, stolen from https://github.com/substack/node-mkdirp
 * @param  {string}   p    Path to directory to make
 * @param  {int}   mode 
 * @param  {Function} cb
 * @return {Promise|null}
 */
VirtualFileSystem.prototype.mkdirP = function(p, mode, cb) {
    // mode is optional
    if (typeof mode === 'function') {
        cb = mode;
        mode = null;
    }

    // return promise
    if (!cb) {
        return this.promise(this.mkdirP, p, mode);
    }

    var fs = this;
    cb = cb || emptyFunction;
    mode = mode || this.options.mode;
        
    p = this.resolve(p);
    
    this.mkdir(p, mode, function (er) {
        if (!er) {
            return cb(null);
        }
        switch (er.code) {
            case 'ENOENT':
                fs.mkdirP(path.dirname(p), mode, function (er) {
                    if (er) cb(er);
                    else fs.mkdirP(p, mode, cb);
                });
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                fs.stat(p, function (er2, stat) {
                    // if the stat fails, then that's super weird.
                    // let the original error be the failure reason.
                    if (er2 || !stat.isDirectory()) cb(er)
                    else cb(null);
                });
                break;
        }
    });
};

/**
 * node-glob(https://github.com/isaacs/node-glob) implement
 * @param  {String}   pattern Pattern to be matched
 * @param  {Object}   options
 * @param  {Function} cb
 */
VirtualFileSystem.prototype.glob = function(pattern, options, cb) {
    if (typeof options === 'function') {
        cb = options;
        options = null;
    }

    if (!cb) {
        return this.promise(this.glob, pattern, options);
    }

    glob(this, pattern, options, cb);
};

VirtualFileSystem.prototype.src = function(pattern, options) {
    return src(this, pattern, options);
};

/**
 * @see vinyl-fs.dest
 * @param  {String|Function} outFolder
 * @param  {Object} opt
 *  - cwd
 *  - mode
 */
VirtualFileSystem.prototype.dest = function(outFolder, opt) {
    return dest(this, outFolder, opt);
};

VirtualFileSystem.inherits = function(init) {
    function FS(options) {
        this.options = options || {};

        if (typeof this.options.mode === 'string') {
            this.options.mode = parseInt(this.options.mode, 8);
        }

        if (typeof init === 'function') {
            init.apply(this);
        }
    }

    inherits(FS, VirtualFileSystem);

    return FS;
}

module.exports = VirtualFileSystem;